"Returns the transform component for 'entity' if it exists, or int2{?, 0} if there is none."
def get_transform_component(scene: H, entity: H) -> H

"Creates a new empty scene."
def new_scene() -> H

"Deletes a scene."
def delete_scene(scene: H)

"Returns the global scene"
def global_scene() -> H

"Returns true if 'entity' is descendant of 'ancestor'"
def is_descendant_entity(scene: H, entity: H, ancestor: H) -> bool

"Deletes an entity from the scene"
def remove_entity(scene: H, entity: H, recursive: bool)

"Duplicates an entity"
def duplicate_entity(scene: H, entity: H) -> H

"Merges src scene into dest scene."
def scene_merge(dest: H, src: H)

"Loads the model from the file into the given scene. Returns valid entity handle if attached==true"
def load_model(scene: H, fname: string, attach: bool) -> H

"Creates a new empty entity"
def create_entity() -> H

"Creates a layer component for the given entity and returns a handle"
def create_layer_component(scene: H, entity: H) -> H

"Gets the layer component for the given entity."
def get_layer_component(scene: H, entity: H) -> H

"Returns the number of entities that have a layer component"
def entity_layer_count(scene: H) -> int

"Returns the nth entity that has a layer component"
def entity_layer_get(scene: H, n: int) -> H

"Creates a humanoid component for the given entity and returns a handle"
def create_humanoid_component(scene: H, entity: H) -> H

"Gets the humanoid component for the given entity."
def get_humanoid_component(scene: H, entity: H) -> H

"Returns the number of entities that have a humanoid component"
def entity_humanoid_count(scene: H) -> int

"Returns the nth entity that has a humanoid component"
def entity_humanoid_get(scene: H, n: int) -> H

"Creates a name component for the given entity, and returns a the handle"
def create_name_component(scene: H, entity: H) -> H

"Sets the name for a name component."
def nc_set_name(name_comp: H, name: string)

"Gets the name of a name component"
def nc_get_name(name_comp: H) -> string

"Gets the name component for the given entity"
def get_name_component(scene: H, entity: H) -> H

"Returns number of entities that have name components."
def entity_names_count(scene: H) -> int

"Returns entity #n that has a name component"
def entity_names_get(scene: H, n: int) -> H

"Searches scene for an entity by name. Returns INVALID_ENTITY if not found."
def find_entity_by_name(scene: H, name: string, ancestor_entity: H) -> H

"Logs to Wicked Engine backlog with given log level"
def backlog(level: int, msg: string)

"Creates a camera component on an entity."
def create_camera_component(scene: H, entity: H) -> H

"Creates a transform component on an entity"
def create_transform_component(scene: H, entity: H) -> H

"Returns the application fixed frame update rate"
def get_fixed_update_rate() -> float

"Sets the camera component used by the 3d renderpath"
def renderpath3d_set_camera(rpath: H, cam_component: H)

"Tranlates transform by 'vec'"
def transform_translate(trans_component: H, v: float3)

"Rotates transform around given quaternion"
def transform_rotate(trans_component: H, quat: float4)

"Gets transform position"
def transform_position(tcomp: H) -> float3

"Gets transform rotation"
def transform_rotation(tcomp: H) -> float4

"Applies local space to world space matrix for transform"
def transform_update_transform(tcomp: H)

"Clears the transform component's transform."
def transform_clear(trans_comp: H)

"Apply euler rotation to transform"
def transform_rotate_roll_pitch_yaw(tcomp: H, angles: float3)

"Apply scale to transform"
def transform_scale(tcomp: H, scale: float3)

"Set this transform to be the linear interpolation of transforms 'a' and 'b'"
def transform_lerp(tcomp: H, a: H, b: H, t: float)


"Gets camera component fov"
def camera_fov(tcomp: H) -> float

"Sets camera component fov, in radians."
def camera_set_fov(tcomp: H, fov: float)

"Gets camera plane dims"
def camera_get_dims(tcomp: H) -> float2

"Sets camera plane dims"
def camera_set_dims(tcomp: H, dims: float2)

"Gets the camera zNear"
def camera_znear(tcomp: H) -> float

"Sets the camera zNear"
def camera_set_znear(tcomp: H, znear: float)

"Gets the camera zFar"
def camera_zfar(tcomp: H) -> float

"Sets the camera zFar"
def camera_set_zfar(tcomp: H, zfar: float)

"Gets the camera focal length"
def camera_focal_length(tcomp: H) -> float

"Sets the camera focal length"
def camera_set_focal_length(tcomp: H, l: float)

"Updates the camera transforms"
def camera_update(tcomp: H)

"Gets the camera component of an entity"
def get_camera_component(scene: H, ent: H) -> H

"Returns the number of cameras in the scene"
def get_camera_count(scene: H) -> int

"returns entity holding the nth camera in the scene"
def get_camera_entity(scene: H, n: int) -> H



"Check if a button is down"
def input_down(button: int, playerindex: int) -> bool

"Check if a button is pressed once"
def input_press(button: int, playerindex: int) -> bool

"Check if a button is held down"
def input_hold(button: int, frames: int, continuous: bool, playerindex: int) -> bool

"get pointer position (eg. mouse pointer) (.xy) + scroll delta (.z) + pressure (.w)"
def input_get_pointer() -> float4

"sets pointer position"
def input_set_pointer(props: float4)

"Hides/shows pointer"
def input_hide_pointer(value: bool)

"Reads input from analog controller axis"
def input_get_analog(axis: int, playerindex: int) -> float4


"Renders debug text in the next frame"
def draw_debug_text(text: string, pos: float3, flags: int, color: float4, scaling: float)


"Creates a wi::Timer"
def create_timer() -> H

"Deletes a timer created with create_timer"
def delete_timer(timer: H)

"Records a reference timestamp"
def timer_record(timer: H)

"Elapsed time since creation or last record call."
def timer_elapsed_seconds(time: H) -> double

"Elapsed time in milliseconds since creation or later record() call"
def timer_elapsed(timer: H) -> double

"wi::font::Params struct"
struct font_params
	position: float3
	size: int
	scaling: float
	rotation: float
	spacing_x: float
	spacing_y: float
	h_align: int
	v_align: int
	color: float4
	shadow_color: float4
	h_wrap: float
	style: int
	softness: float
	bolden: float
	shadow_softness: float
	shadow_bolden: float
	shadow_offset_x: float
	shadow_offset_y: float
	cursor: float4
	hdr_scaling: float

end


"Creates a SpriteFont"
def create_sprite_font() -> H

"Sets the font_params for a sprite font"
def sprite_font_set_params(font: H, font_params: H)

"Deletes a SpriteFont"
def delete_sprite_font(font: H)

"Changes fonts hidden state"
def sprite_font_set_hidden(font: H, value: bool)

"Returns dimensions of the text"
def sprite_font_text_size(font: H) -> float2

"Sets the text TODO is non-wstring version of this utf8 friendly?"
def sprite_font_set_text(font: H, txt: string)

"Gets the text"
def sprite_font_get_text(font: H) -> string


"wi::scene::HumanoidComponent"
struct humanoid!
	default_look_direction: float3
	head_rotation_max: float2
	head_rotation_speed: float
	eye_rotation_max: float2
	eye_rotation_speed: float
	look_at: float3
end

"Returns number of bones in humanoid component"
def humanoid_bone_count(hum: H) -> int

"Returns entity for bone with the given HumanoidBone name"
def humanoid_bone(hum: H, i: int) -> H

"Is lookat enabled?"
def humanoid_is_lookat_enabled(hum: H) -> bool

"Sets lookat for humanoid component"
def humanoid_set_lookat_enabled(hum: H, v: bool)


"wi::scene::Layer component"
struct layer!
	mask: int
	propagation_mask: int
end


"Returns the games RenderPath3d"
def get_renderpath3d() -> H

"Adds a sprite font to the renderpath"
def renderpath_add_font(path: H, sprite_font: H, layer: string)

"Removes a sprite font from the renderpath"
def renderpath_remove_font(path: H, sprite_font: H) 

"Clears all fonts from renderpath"
def renderpath_clear_fonts(path: H)

"Returns the order for the given font"
def renderpath_font_order(path: H, sprite_font: H) -> int

"Sets the order for the given font"
def renderpath_set_font_order(path: H, sprite_font: H, order: int)

