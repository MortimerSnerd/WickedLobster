"Returns the transform component for 'entity' if it exists, or int2{?, 0} if there is none."
def get_transform_component(scene: H, entity: H) -> H

"Creates a new empty scene."
def new_scene() -> H

"Deletes a scene."
def delete_scene(scene: H)

"Returns the global scene"
def global_scene() -> H

"Returns true if 'entity' is descendant of 'ancestor'"
def is_descendant_entity(scene: H, entity: H, ancestor: H) -> bool

"Retargets an animation from one humanoid to another and returns resulting entity"
def retarget_animation(scene: H, dest_entity: H, src_entity: H, bake_data: bool) -> H

"Deletes an entity from the scene"
def remove_entity(scene: H, entity: H, recursive: bool)

"Duplicates an entity"
def duplicate_entity(scene: H, entity: H) -> H

"Merges src scene into dest scene."
def scene_merge(dest: H, src: H)

"Loads the model from the file into the given scene. Returns valid entity handle if attached==true"
def load_model(scene: H, fname: string, attach: bool) -> H

"Creates a new empty entity"
def create_entity() -> H

"Creates a layer component for the given entity and returns a handle"
def create_layer_component(scene: H, entity: H) -> H

"Gets the layer component for the given entity."
def get_layer_component(scene: H, entity: H) -> H

"Returns the number of entities that have a layer component"
def entity_layer_count(scene: H) -> int

"Returns the nth entity that has a layer component"
def entity_layer_get(scene: H, n: int) -> H

"Creates a humanoid component for the given entity and returns a handle"
def create_humanoid_component(scene: H, entity: H) -> H

"Gets the humanoid component for the given entity."
def get_humanoid_component(scene: H, entity: H) -> H

"Returns the number of entities that have a humanoid component"
def entity_humanoid_count(scene: H) -> int

"Returns the nth entity that has a humanoid component"
def entity_humanoid_get(scene: H, n: int) -> H

"Creates a name component for the given entity, and returns a the handle"
def create_name_component(scene: H, entity: H) -> H

"Sets the name for a name component."
def nc_set_name(name_comp: H, name: string)

"Gets the name of a name component"
def nc_get_name(name_comp: H) -> string

"Gets the name component for the given entity"
def get_name_component(scene: H, entity: H) -> H

"Returns number of entities that have name components."
def entity_names_count(scene: H) -> int

"Returns entity #n that has a name component"
def entity_names_get(scene: H, n: int) -> H

"Searches scene for an entity by name. Returns INVALID_ENTITY if not found."
def find_entity_by_name(scene: H, name: string, ancestor_entity: H) -> H

"Logs to Wicked Engine backlog with given log level"
def backlog(level: int, msg: string)

"Returns true if the backlog is active"
def is_backlog_active() -> bool

"Creates a camera component on an entity."
def create_camera_component(scene: H, entity: H) -> H

"Creates a transform component on an entity"
def create_transform_component(scene: H, entity: H) -> H

"Creates a transform component attached to no scene or entity.  Seems to be used primarly for calculations from scripts"
def create_transform() -> H

"Deletes a transform created by create_transform()"
def delete_transform(trans: H)

"Returns the application fixed frame update rate"
def get_fixed_update_rate() -> float

"Sets the camera component used by the 3d renderpath"
def renderpath3d_set_camera(rpath: H, cam_component: H)

"Tranlates transform by 'vec'"
def transform_translate(trans_component: H, v: float3)

"Rotates transform around given quaternion"
def transform_rotate(trans_component: H, quat: float4)

"Gets transform position"
def transform_position(tcomp: H) -> float3

"Gets transform rotation"
def transform_rotation(tcomp: H) -> float4

"Applies local space to world space matrix for transform"
def transform_update_transform(tcomp: H)

"Clears the transform component's transform."
def transform_clear(trans_comp: H)

"Apply euler rotation to transform"
def transform_rotate_roll_pitch_yaw(tcomp: H, angles: float3)

"Apply scale to transform"
def transform_scale(tcomp: H, scale: float3)

"Set this transform to be the linear interpolation of transforms 'a' and 'b'"
def transform_lerp(tcomp: H, a: H, b: H, t: float)

"gets the local matrix for the transform"
def get_transform_local_matrix(tcomp: H) -> H 

"gets the world matrix for the transform"
def get_transform_world_matrix(tcomp: H) -> H

"Trasforms the transform by the given matrix"
def transform_transform_matrix(tcomp: H, matrix: H)

"Gets camera component fov"
def camera_fov(tcomp: H) -> float

"Sets camera component fov, in radians."
def camera_set_fov(tcomp: H, fov: float)

"Gets camera plane dims"
def camera_get_dims(tcomp: H) -> float2

"Sets camera plane dims"
def camera_set_dims(tcomp: H, dims: float2)

"Gets the camera zNear"
def camera_znear(tcomp: H) -> float

"Sets the camera zNear"
def camera_set_znear(tcomp: H, znear: float)

"Gets the camera zFar"
def camera_zfar(tcomp: H) -> float

"Sets the camera zFar"
def camera_set_zfar(tcomp: H, zfar: float)

"Gets the camera focal length"
def camera_focal_length(tcomp: H) -> float

"Sets the camera focal length"
def camera_set_focal_length(tcomp: H, l: float)

"Updates the camera transforms"
def camera_update(tcomp: H)

"Sets the camera transform from another transform component"
def transform_camera(camera: H, tcomp: H)

"Sets the camera's transform from the matris"
def transform_camera_set_matrix(camera: H, matrix: H)

"Gets the camera component of an entity"
def get_camera_component(scene: H, ent: H) -> H

"Returns the number of cameras in the scene"
def get_camera_count(scene: H) -> int

"returns entity holding the nth camera in the scene"
def get_camera_entity(scene: H, n: int) -> H

"wi::scene::CameraComponent"
struct camera!
	eye: float3
	at: float3
	up: float3
endstruct



"Check if a button is down"
def input_down(button: int, playerindex: int) -> bool

"Check if a button is pressed once"
def input_press(button: int, playerindex: int) -> bool

"Check if a button is held down"
def input_hold(button: int, frames: int, continuous: bool, playerindex: int) -> bool

"get pointer position (eg. mouse pointer) (.xy) + scroll delta (.z) + pressure (.w)"
def input_get_pointer() -> float4

"sets pointer position"
def input_set_pointer(props: float4)

"Hides/shows pointer"
def input_hide_pointer(value: bool)

"Reads input from analog controller axis"
def input_get_analog(axis: int, playerindex: int) -> float4


"Renders debug text in the next frame"
def draw_debug_text(text: string, pos: float3, flags: int, color: float4, scaling: float)


"Creates a wi::Timer"
def create_timer() -> H

"Deletes a timer created with create_timer"
def delete_timer(timer: H)

"Records a reference timestamp"
def timer_record(timer: H)

"Elapsed time since creation or last record call."
def timer_elapsed_seconds(time: H) -> double

"Elapsed time in milliseconds since creation or later record() call"
def timer_elapsed(timer: H) -> double

"wi::font::Params struct"
struct font_params
	position: float3
	size: int
	scaling: float
	rotation: float
	spacing_x: float
	spacing_y: float
	h_align: int
	v_align: int
	color: float4
	shadow_color: float4
	h_wrap: float
	style: int
	softness: float
	bolden: float
	shadow_softness: float
	shadow_bolden: float
	shadow_offset_x: float
	shadow_offset_y: float
	cursor: float4
	hdr_scaling: float

endstruct


"Creates a SpriteFont"
def create_sprite_font() -> H

"Sets the font_params for a sprite font"
def sprite_font_set_params(font: H, font_params: H)

"Deletes a SpriteFont"
def delete_sprite_font(font: H)

"Changes fonts hidden state"
def sprite_font_set_hidden(font: H, value: bool)

"Returns dimensions of the text"
def sprite_font_text_size(font: H) -> float2

"Sets the text TODO is non-wstring version of this utf8 friendly?"
def sprite_font_set_text(font: H, txt: string)

"Gets the text"
def sprite_font_get_text(font: H) -> string


"wi::scene::HumanoidComponent"
struct humanoid!
	default_look_direction: float3
	head_rotation_max: float2
	head_rotation_speed: float
	eye_rotation_max: float2
	eye_rotation_speed: float
	look_at: float3
endstruct

"Returns number of bones in humanoid component"
def humanoid_bone_count(hum: H) -> int

"Returns entity for bone with the given HumanoidBone name"
def humanoid_bone(hum: H, i: int) -> H

"Is lookat enabled?"
def humanoid_is_lookat_enabled(hum: H) -> bool

"Sets lookat for humanoid component"
def humanoid_set_lookat_enabled(hum: H, v: bool)


"wi::scene::Layer component"
struct layer!
	mask: int
	propagation_mask: int
endstruct


"Returns the games RenderPath3d"
def get_renderpath3d() -> H

"Adds a sprite font to the renderpath"
def renderpath_add_font(path: H, sprite_font: H, layer: string)

"Removes a sprite font from the renderpath"
def renderpath_remove_font(path: H, sprite_font: H) 

"Clears all fonts from renderpath"
def renderpath_clear_fonts(path: H)

"Returns the order for the given font"
def renderpath_font_order(path: H, sprite_font: H) -> int

"Sets the order for the given font"
def renderpath_set_font_order(path: H, sprite_font: H, order: int)

"Returns the physical pixel dimensions of the renderpath"
def get_renderpath_physical_dims(path: H) -> int2

"Returns the logical dims of the renderpath"
def get_renderpath_logical_dims(path: H) -> float2

"wi::RenderPath3d"
struct renderpath3d!
	exposure: float
	brightness: float
	contrast: float
	saturation: float
	bloom_threshold: float
	motion_blur_strength: float
	depth_of_field_strength: float
	sharpen_filter_amount: float
	outline_threshold: float
	outline_thickness: float
	outline_color: float4
	ao_range: float
	ao_sample_count: int
	ao_power: float
	chromatic_aberration_amount: float
	screen_space_shadow_sample_count: int
	screen_space_shadow_range: float
	eye_adaption_key: float
	eye_adaption_rate: float
	fsr_sharpness: float
	fsr2_sharpness: float
	light_shafts_strength: float
	raytraced_diffuse_range: float
	raytraced_reflections_range: float
	reflection_roughness_cutoff: float
	ssr_enabled: bool
	raytraced_diffuse_enabled: bool
	raytraced_reflection_enabled: bool
	shadows_enabled: bool
	reflections_enabled: bool
	fxaa_enabled: bool
	bloom_enabled: bool
	color_grading_enabled: bool
	volume_lights_enabled: bool
	light_shafts_enabled: bool
	lens_flare_enabled: bool
	motion_blur_enabled: bool
	depth_of_field_enabled: bool
	eye_adaptation_enabled: bool
	sharpen_filter_enabled: bool
	outline_enabled: bool
	chromatic_aberration_enabled: bool
	dither_enabled: bool
	occlusion_culling_enabled: bool
	scene_update_enabled: bool
	fsr_enabled: bool
	fsr2_enabled: bool
	vxgi_resolve_full_resolution_enabled: bool
endstruct

"Returns true if AO is enabled"
def get_renderpath3d_ao_enabled(renderpath3d: H) -> bool

"Set the AO mode"
def set_renderpath3d_ao(renderpath3d: H, v: int)


"wi::scene::ColliderComponent"
struct collider!
	shape: int
	radius: float
	offset: float3
	tail: float3
endstruct

"Set collider as gpu enabled"
def set_collider_is_gpu_enabled(collider: H, v: bool)

"Set collider as cpu enabled"
def set_collider_is_cpu_enabled(collider: H, v: bool)


"Creates a collider component for the given entity and returns a handle"
def create_collider_component(scene: H, entity: H) -> H

"Gets the collider component for the given entity."
def get_collider_component(scene: H, entity: H) -> H

"Returns the number of entities that have a collider component"
def entity_collider_count(scene: H) -> int

"Returns the nth entity that has a collider component"
def entity_collider_get(scene: H, n: int) -> H


"Creates a matrix"
def create_matrix4x4() -> H

"Deletes a matrix"
def delete_matrix(m: H)

"Initializes the matrix as an identity matrix"
def identity_matrix(m: H)

"Transforms a vector with the matrix"
def transform_vector(matrix: H, v: float4) -> float4

"Assigns matrix lhs the value from rhs"
def assign_matrix(lhs: H, rhs: H)

"Returns the translation part of the given matrix"
def get_matrix_translation(matrix: H) -> float3

"Initializes a matrix from rows"
def assign_matrix_rows(m: H, r1: float4, r2: float4, r3: float4, r4: float4)

"Returns a row from a matrix"
def return_matrix_row(m: H, r: int) -> float4

"Set up as a translation matrix"
def translation_matrix(m: H, v: float3)

"Set up as a rotation matrix"
def rotation_euler_matrix(m: H, angles: float3)

"Set up as a rotation around x matrix"
def rotation_x_matrix(m: H, a: float)

"Set up as a rotation around y matrix"
def rotation_y_matrix(m: H, a: float)

"Set up as a rotation around z matrix"
def rotation_z_matrix(m: H, a: float)

"Set matrix as quaternion rotation"
def rotation_quat_matrix(m: H, quat: float4)

"Set up matrix as a scaling matrix"
def scaling_matrix(m: H, scale: float4)

"Set up matrix to look to a pos"
def look_to_matrix(m: H, eyepos: float3, eyedir: float3, up: float3)

"Set up matrix to look at a pos"
def look_at_matrix(m: H, eyepos: float3, focuspos: float3, up: float3)

"Multiply lhs by rhs and put the reuslt into result"
def multiply_matrix(lhs: H, rhs: H, result: H)

"Add lhs and rhs, and put the result in result"
def add_matrix(lhs: H, rhs: H, result: H)

"Transpose a matrix"
def transpose_matrix(m: H, result: H)

"Inverts 'm' and puts the result in 'result'"
def invert_matrix(m: H, result: H)


"wi::scene::AnimationComponent"
struct animation!
	start: float
	end: float
	timer: float
	amount: float
	speed: float
endstruct

"Returns true if animation is playing"
def is_animation_playing(anim: H) -> bool

"Returns true if the animation is looped"
def is_animation_looped(anim: H) -> bool

"Returns the length of the animation"
def get_animation_length(anim: H) -> float

"Returns true if the animation has ended"
def is_animation_ended(anim: H) -> float

"Plays an animation"
def play_animation(anim: H)

"Pauses an animation"
def pause_animation(anim: H)

"Stops an animation"
def stop_animation(anim: H)

"Sets the animation as looped/not-looped"
def set_animation_looped(anim: H, v: bool)

"Creates a animation component for the given entity and returns a handle"
def create_animation_component(scene: H, entity: H) -> H

"Gets the animation component for the given entity."
def get_animation_component(scene: H, entity: H) -> H

"Returns the number of entities that have a animation component"
def entity_animation_count(scene: H) -> int

"Returns the nth entity that has a animation component"
def entity_animation_get(scene: H, n: int) -> H


"Controls VXGI"
def renderer_set_vxgi_enabled(v: bool)

"Returns true if VXGI is enabled"
def renderer_vxgi_enabled() -> bool


"Primitive to primitive intersection test, returns true|false,distance,direction"
def sphere_sphere_intersects(sphere0: H, sphere1: H) -> bool,float,float3

